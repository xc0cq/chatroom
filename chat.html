<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>0PM</title>
  <style>
    :root{--accent:#8304e0;--accent-dark:#5302b8}
    html,body{height:100%;margin:0;}
    body{
      background: linear-gradient(135deg,#000000,#0b0022);
      font-family: Arial, Helvetica, sans-serif;
      color:#fff;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
      padding:18px;
      box-sizing:border-box;
    }
    header{width:100%;max-width:900px;display:flex;align-items:center;justify-content:space-between;}
    h1{margin:0;font-size:20px;letter-spacing:2px;color:var(--accent);}
    #container{width:100%;max-width:900px;background:rgba(255,255,255,0.03);border-radius:12px;overflow:hidden;display:flex;flex-direction:column;height:78vh;box-shadow:0 6px 30px rgba(0,0,0,0.6);}
    #onlineUsers{padding:8px 12px;background:rgba(0,0,0,0.25);border-bottom:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:center;flex-wrap:wrap;}
    #onlineUsers span{background:rgba(131,4,224,0.12);padding:4px 8px;border-radius:999px;font-weight:600;color:#fff;}
    #messages{flex:1;overflow:auto;padding:16px;display:flex;flex-direction:column;gap:8px;}
    .message{background:rgba(255,255,255,0.035);padding:10px;border-radius:8px;position:relative;display:flex;flex-direction:column;gap:6px;}
    .top-row{display:flex;align-items:center;gap:8px;justify-content:space-between;}
    .left{display:flex;align-items:center;gap:8px;}
    .username{font-weight:700;cursor:default;}
    .username.rainbow{background:linear-gradient(270deg,red,orange,yellow,green,blue,indigo,violet);background-size:1400% 1400%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:rainbowShift 6s linear infinite;}
    .username.goldblack{background:linear-gradient(270deg,#FFD700,#000,#FFD700);background-size:600% 600%;-webkit-background-clip:text;-webkit-text-fill-color:transparent;animation:goldBlackShift 5s linear infinite;}
    @keyframes rainbowShift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
    @keyframes goldBlackShift{0%{background-position:0% 50%}50%{background-position:100% 50%}100%{background-position:0% 50%}}
    .timestamp{font-size:12px;color:#bdbdbd;}
    .text{white-space:pre-wrap;word-break:break-word;color:#e9e9e9;}
    .reply-quote{border-left:3px solid var(--accent);padding-left:8px;color:#cfcfcf;font-style:italic;font-size:13px;}
    .actions{position:absolute;right:10px;top:10px;display:flex;gap:6px;opacity:0;transition:opacity .12s ease;}
    .message:hover .actions{opacity:1;}
    .actions button{background:transparent;border:none;color:#cfcfcf;cursor:pointer;padding:4px 8px;border-radius:6px;font-size:13px;}
    .reactions{display:flex;gap:6px;margin-top:6px;flex-wrap:wrap;}
    .reaction{background:rgba(0,0,0,0.4);padding:4px 8px;border-radius:999px;display:inline-flex;gap:6px;align-items:center;cursor:pointer;font-size:13px;}
    .reaction.self{background:var(--accent);}
    .reaction .tooltip{display:none;position:absolute;background:#222;padding:6px;border-radius:6px;font-size:12px;top:-36px;left:50%;transform:translateX(-50%);white-space:nowrap;}
    .reaction:hover .tooltip{display:block;}
    /* input area fixed */
    #inputArea{padding:12px;background:linear-gradient(180deg,rgba(0,0,0,0.2),rgba(0,0,0,0.35));border-top:1px solid rgba(255,255,255,0.03);display:flex;gap:8px;align-items:flex-end;flex-wrap:wrap;}
    #replyingTo{width:100%;color:var(--accent);font-style:italic;margin-bottom:4px;display:none;}
    textarea#messageInput{flex:1;min-height:48px;max-height:140px;padding:10px;border-radius:8px;border:none;background:#121212;color:#fff;resize:none;box-sizing:border-box;}
    button#sendBtn{background:linear-gradient(90deg,var(--accent-dark),var(--accent));color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer;}
    button#cancelEdit{display:none;background:#a83232;padding:8px 10px;border-radius:8px;border:none;color:#fff;cursor:pointer;}
    /* history modal */
    #historyModal{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);background:#0f0f16;padding:16px;border-radius:12px;display:none;max-height:70vh;overflow:auto;z-index:9999;box-shadow:0 10px 40px rgba(0,0,0,0.6);}
    #historyModal h3{color:var(--accent);margin:0 0 8px 0;}
    #onlineWrap{display:flex;align-items:center;gap:8px;}
  </style>
</head>
<body>
  <header><h1>0PM</h1><div id="onlineWrap"><small>Online</small>&nbsp;<div id="onlineUsers"></div></div></header>

  <main id="container" role="main" aria-live="polite">
    <div id="messages" aria-live="polite" aria-atomic="false"></div>

    <div id="inputArea" role="region" aria-label="Message input area">
      <div id="replyingTo" aria-hidden="true"></div>
      <textarea id="messageInput" placeholder="Type a message..."></textarea>
      <button id="sendBtn">Send</button>
      <button id="cancelEdit">Cancel Edit</button>
      <div id="typingIndicator" style="width:100%;color:#ccc;font-size:13px;"></div>
    </div>
  </main>

  <div id="historyModal" role="dialog" aria-modal="true"><button id="closeHistory" style="float:right;background:transparent;border:none;color:#fff;font-size:18px;cursor:pointer;">✕</button><h3>Edit History</h3><div id="historyList" style="font-family:monospace;white-space:pre-wrap;color:#ddd"></div></div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

  <script>
    // Firebase config (unchanged)
    const firebaseConfig = {
      apiKey: "AIzaSyC-9Hk4TBPi4WLb4anO-84FDpIfjH8X8HY",
      authDomain: "chatting-f1958.firebaseapp.com",
      databaseURL: "https://chatting-f1958-default-rtdb.firebaseio.com",
      projectId: "chatting-f1958",
      storageBucket: "chatting-f1958.appspot.com",
      messagingSenderId: "308400029505",
      appId: "1:308400029505:web:a265599a58f1881e83abc0"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // Realtime refs
    const messagesRef = db.ref("messages");
    const typingRef = db.ref("typing");
    const presenceRef = db.ref("presence");

    // Get logged-in username from localStorage
    const username = localStorage.getItem("chatUser");
    if (!username) { window.location.href = "index.html"; }

    // Admin list (lowercase)
    const adminUsers = ["admin"];

    // Gradient mapping
    const userGradientClasses = { "justin":"rainbow", "mason":"goldblack" };

    // DOM refs
    const messagesDiv = document.getElementById("messages");
    const onlineUsersDiv = document.getElementById("onlineUsers");
    const msgInput = document.getElementById("messageInput");
    const sendBtn = document.getElementById("sendBtn");
    const cancelEditBtn = document.getElementById("cancelEdit");
    const replyingToDiv = document.getElementById("replyingTo");
    const typingIndicator = document.getElementById("typingIndicator");

    const historyModal = document.getElementById("historyModal");
    const historyList = document.getElementById("historyList");
    const closeHistory = document.getElementById("closeHistory");

    // State
    let editingId = null;
    let replyingTo = null;
    let typingTimeout = null;
    const messageEls = {};

    // --- SAFE CHAT: bad words list & regex builder ---
    const badWords = [
      // Core list (lowercase base forms)
      "fuck","shit","bitch","asshole","dick","cock","pussy","cunt","whore","slut",
      // racial slur bases (kept as base strings inside code only)
      "nigger","nigga","kike","chink","spic","gook","wetback"
    ];

    // Build a forgiving pattern that allows non-letters between letters (to catch fvck, f.v.c.k, sh1t...)
    function wordToPattern(word) {
      // escape regex special chars in letters just in case
      const parts = word.split("").map(ch => ch.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"));
      // allow any number of non-letter/digit characters between letters, but require letters/digits to appear
      return parts.join("[\\W_]*");
    }

    const badPatterns = badWords.map(w => new RegExp(wordToPattern(w), "gi"));

    // Replace matched substring with same-length '#' characters
    function censorText(input) {
      let out = input;
      badPatterns.forEach(pat => {
        out = out.replace(pat, match => "#".repeat(match.replace(/\s+/g,"").length || match.length));
      });
      return out;
    }

    // Presence: mark online and remove on disconnect
    (function setPresence(){
      const myRef = presenceRef.child(username);
      myRef.set(true);
      myRef.onDisconnect().remove();
    })();

    // Update online users list
    presenceRef.on("value", snap => {
      const users = snap.val() || {};
      const names = Object.keys(users);
      onlineUsersDiv.innerHTML = names.length ? names.map(u => {
        const cls = userGradientClasses[u.toLowerCase()];
        if (cls==="rainbow") return `<span class="username rainbow">${u}</span>`;
        if (cls==="goldblack") return `<span class="username goldblack">${u}</span>`;
        return `<span>${u}</span>`;
      }).join(" ") : "<span>No one online</span>";
    });

    // Typing indicator debounce
    msgInput.addEventListener("input", () => {
      typingRef.child(username).set(true);
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(()=> typingRef.child(username).remove(), 1400);
    });
    typingRef.on("value", snap => {
      const val = snap.val() || {};
      const others = Object.keys(val).filter(u=>u!==username);
      typingIndicator.textContent = others.length===0 ? "" : (others.length===1? `${others[0]} is typing...` : "Multiple users are typing...");
    });

    // UTIL: format times
    function fmt(ts){ if(!ts) return ""; const d=new Date(ts); return d.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}); }

    // --- Render / update messages ---
    function renderMsgSnapshot(snap) {
      const raw = snap.val(); if (!raw) return;
      const id = snap.key;
      const msg = Object.assign({}, raw); msg.id = id;

      // create DOM
      const entry = document.createElement("div");
      entry.className = "message";
      entry.id = "m-"+id;

      // reply quote
      if (msg.replyTo && messageEls[msg.replyTo]) {
        const q = document.createElement("div"); q.className="reply-quote"; q.textContent = `↳ ${messageEls[msg.replyTo].msg.user}: ${messageEls[msg.replyTo].msg.text.slice(0,60)}${messageEls[msg.replyTo].msg.text.length>60?"...":""}`;
        entry.appendChild(q);
      }

      const top = document.createElement("div"); top.className="top-row";
      const left = document.createElement("div"); left.className="left";
      const uname = document.createElement("span"); uname.className="username";
      const mapped = userGradientClasses[msg.user.toLowerCase()];
      if (mapped==="rainbow") uname.classList.add("rainbow");
      if (mapped==="goldblack") uname.classList.add("goldblack");
      uname.textContent = msg.user;
      left.appendChild(uname);
      const time = document.createElement("span"); time.className="timestamp"; time.textContent = fmt(msg.timestamp);
      top.appendChild(left); top.appendChild(time);
      entry.appendChild(top);

      const text = document.createElement("div"); text.className="text"; text.textContent = msg.text + (msg.edited?" (edited)":"");
      entry.appendChild(text);

      // reactions
      const reactionsDiv = document.createElement("div"); reactionsDiv.className="reactions";
      const reactions = msg.reactions || {};
      Object.entries(reactions).forEach(([emoji, usersObj]) => {
        const users = usersObj || {};
        const count = Object.keys(users).length;
        const reacted = !!users[username];
        const btn = document.createElement("div"); btn.className="reaction"+(reacted?" self":""); btn.textContent = `${emoji} ${count}`;
        const tooltip = document.createElement("span"); tooltip.className="tooltip"; tooltip.textContent = Object.keys(users).join(", ");
        btn.appendChild(tooltip);
        btn.onclick = ()=> toggleReaction(id, emoji, reacted);
        reactionsDiv.appendChild(btn);
      });
      // add reaction button
      const addBtn = document.createElement("div"); addBtn.className="reaction"; addBtn.textContent = "+"; addBtn.onclick = ()=> promptReaction(id);
      reactionsDiv.appendChild(addBtn);
      entry.appendChild(reactionsDiv);

      // actions (reply always, edit/delete owner or admin, history)
      const actions = document.createElement("div"); actions.className="actions";
      const replyBtn = document.createElement("button"); replyBtn.textContent="Reply"; replyBtn.onclick = ()=> startReply(msg);
      actions.appendChild(replyBtn);

      if (msg.user === username) {
        const editBtn = document.createElement("button"); editBtn.textContent="Edit"; editBtn.onclick = ()=> startEdit(id);
        actions.appendChild(editBtn);
      }
      if (msg.user === username || adminUsers.includes(username.toLowerCase())) {
        const delBtn = document.createElement("button"); delBtn.textContent="Delete"; delBtn.onclick = ()=> deleteMsg(id);
        actions.appendChild(delBtn);
      }
      if (msg.edited && Array.isArray(msg.history) && msg.history.length>0) {
        const histBtn = document.createElement("button"); histBtn.textContent="History"; histBtn.onclick = ()=> showHistory(msg.history);
        actions.appendChild(histBtn);
      }
      entry.appendChild(actions);

      messagesDiv.appendChild(entry);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;

      messageEls[id] = { el: entry, msg: msg };
    }

    function updateMsgSnapshot(snap) {
      const raw = snap.val(); if(!raw) return;
      const id = snap.key; const msg = Object.assign({}, raw); msg.id = id;
      const stored = messageEls[id];
      if (!stored) { renderMsgSnapshot(snap); return; }

      stored.msg = msg;
      const el = stored.el;
      // update reply quote
      const q = el.querySelector(".reply-quote");
      if (msg.replyTo) {
        if (!q && messageEls[msg.replyTo]) {
          const replyMsg = messageEls[msg.replyTo].msg;
          const newQ = document.createElement("div"); newQ.className="reply-quote"; newQ.textContent = `↳ ${replyMsg.user}: ${replyMsg.text.slice(0,60)}${replyMsg.text.length>60?"...":""}`;
          el.insertBefore(newQ, el.firstChild);
        } else if (q && messageEls[msg.replyTo]) {
          const replyMsg = messageEls[msg.replyTo].msg; q.textContent = `↳ ${replyMsg.user}: ${replyMsg.text.slice(0,60)}${replyMsg.text.length>60?"...":""}`;
        }
      } else if (q) q.remove();

      // username class
      const uname = el.querySelector(".username"); uname.textContent = msg.user;
      uname.className = "username"; const mapped = userGradientClasses[msg.user.toLowerCase()]; if (mapped==="rainbow") uname.classList.add("rainbow"); if (mapped==="goldblack") uname.classList.add("goldblack");

      // timestamp
      const time = el.querySelector(".timestamp"); if (time) time.textContent = fmt(msg.timestamp);

      // text
      const text = el.querySelector(".text"); text.textContent = msg.text + (msg.edited?" (edited)":"");

      // reactions rebuild
      const reactionsDiv = el.querySelector(".reactions"); reactionsDiv.innerHTML = "";
      const reactions = msg.reactions || {};
      Object.entries(reactions).forEach(([emoji, usersObj])=> {
        const users = usersObj||{}; const count = Object.keys(users).length; const reacted = !!users[username];
        const btn = document.createElement("div"); btn.className="reaction"+(reacted?" self":""); btn.textContent=`${emoji} ${count}`;
        const tooltip = document.createElement("span"); tooltip.className="tooltip"; tooltip.textContent = Object.keys(users).join(", ");
        btn.appendChild(tooltip); btn.onclick = ()=> toggleReaction(id, emoji, reacted); reactionsDiv.appendChild(btn);
      });
      const addBtn = document.createElement("div"); addBtn.className="reaction"; addBtn.textContent="+"; addBtn.onclick = ()=> promptReaction(id); reactionsDiv.appendChild(addBtn);

      // actions may change (history etc) - simple approach: update nothing else here
    }

    function removeMsgSnapshot(snap) {
      const id = snap.key; const stored = messageEls[id]; if (!stored) return; stored.el.remove(); delete messageEls[id];
    }

    // --- Sending / Editing with censorship ---
    function sendMessage() {
      const raw = msgInput.value.trim(); if (!raw) return;
      const censored = censorText(raw);
      if (editingId) {
        // append to history then update
        messagesRef.child(editingId).once("value").then(snap=> {
          const old = snap.val()||{}; const history = old.history||[]; history.push({text: old.text, timestamp: old.timestamp||Date.now()});
          messagesRef.child(editingId).update({ text: censored, edited:true, history:history, timestamp:Date.now(), replyTo: replyingTo?replyingTo.id:null });
          clearInputState();
        });
      } else {
        messagesRef.push({ user: username, text: censored, timestamp: Date.now(), replyTo: replyingTo?replyingTo.id:null, reactions: {} });
        clearInputState();
      }
    }
    sendBtn.addEventListener("click", sendMessage);
    msgInput.addEventListener("keydown", (e)=> { if(e.key==="Enter" && !e.shiftKey){ e.preventDefault(); sendMessage(); } });

    function clearInputState(){ editingId=null; replyingTo=null; msgInput.value=""; sendBtn.textContent="Send"; cancelEditBtn.style.display="none"; replyingToDiv.style.display="none"; replyingToDiv.textContent=""; }

    // start edit
    function startEdit(id){ messagesRef.child(id).once("value").then(snap=>{ const m = snap.val(); if(!m) return; if(m.user!==username) return alert("You can only edit your messages."); editingId=id; replyingTo=null; msgInput.value = m.text; msgInput.focus(); sendBtn.textContent="Save"; cancelEditBtn.style.display="inline-block"; }); }
    cancelEditBtn.addEventListener("click", clearInputState);

    // delete
    function deleteMsg(id){ if(!confirm("Delete this message?")) return; messagesRef.child(id).remove(); }

    // reply
    function startReply(msgObj){ replyingTo=msgObj; replyingToDiv.style.display="block"; replyingToDiv.textContent = `Replying to ${msgObj.user}: \"${msgObj.text.slice(0,80)}${msgObj.text.length>80?"...":""}\"`; msgInput.focus(); }

    // reactions
    function toggleReaction(messageId, emoji, reacted){
      const path = messagesRef.child(messageId).child("reactions").child(emoji).child(username);
      if(reacted) path.remove(); else path.set(true);
    }
    function promptReaction(id){
      const emoji = prompt("Enter an emoji (e.g. 👍, 😊):");
      if(!emoji) return;
      messagesRef.child(id).child("reactions").child(emoji).child(username).set(true);
    }

    // show history
    function showHistory(hist){
      historyList.innerHTML = ""; if(!Array.isArray(hist)||hist.length===0){ historyList.textContent="No history."; } else { hist.slice().reverse().forEach(h=>{ const p=document.createElement("div"); p.textContent = `${new Date(h.timestamp).toLocaleString()}: ${h.text}`; p.style.padding="6px 0"; historyList.appendChild(p); }); } historyModal.style.display="block"; }
    closeHistory.addEventListener("click", ()=> historyModal.style.display="none");

    // message listeners
    messagesRef.on("child_added", renderMsgSnapshot);
    messagesRef.on("child_changed", updateMsgSnapshot);
    messagesRef.on("child_removed", removeMsgSnapshot);

    // --- Presence typing ---
    (function setTypingPresence(){ const r = typingRef.child(username); r.onDisconnect().remove(); })();
    // typing state handled earlier for input: we set values
    // For presence we already set presence earlier: same idea
    (function setPresence(){ const r = presenceRef.child(username); r.set(true); r.onDisconnect().remove(); })();

    // --- SAFE CENSOR: build patterns from badWords ---
    function wordToPattern(word){
      const parts = word.split("").map(ch=>ch.replace(/[-/\\^$*+?.()|[\]{}]/g,"\\$&"));
      return parts.join("[\\W_]*");
    }
    const badPatterns = badWords.map(w=> new RegExp(wordToPattern(w),"gi"));
    // censor that returns same-length #'s for matched characters (excluding spaces)
    function censorText(input){
      let out = input;
      badPatterns.forEach(p => {
        out = out.replace(p, match => "#".repeat(match.replace(/\s+/g,"").length || match.length));
      });
      return out;
    }

    // small safety: trim extremely long messages
    function enforceLimits(text){ if(text.length>2000) return text.slice(0,2000); return text; }

  </script>
</body>
</html>
